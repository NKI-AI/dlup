from __future__ import annotations

import functools
import itertools
import math
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any

from PIL import Image

from dlup.backends.common import AbstractSlideBackend
from dlup.types import PathLike

RELEVANT_VIPS_PROPERTIES = {
    "openslide.vendor": str,
    "openslide.mpp-x": float,
    "openslide.mpp-y": float,
    "openslide.objective-power": int,
    "openslide.bounds-height": int,
    "openslide.bounds-width": int,
    "openslide.bounds-x": int,
    "openslide.bounds-y": int,
    "vips-loader": str,
}
METADATA_CACHE = 128


def parse_xml_to_dict(file_path: PathLike) -> dict[str, Any]:
    """Parse XML file with name space. vips-properties.xml files will extract every property name-value pair in
    `properties`.

    Parameters
    ----------
    file_path : Pathlike
        Path to XML space

    Returns
    -------
    dict[str, Any]
        Parsed XML file as a dictionary. Name space will be replaced with an empty string.
    """
    root = ET.parse(file_path).getroot()
    namespace = root.tag.split("}")[0] + "}" if len(root.tag.split("}")) > 1 else ""
    parsed_dict = {root.tag.replace(namespace, ""): dict(root.attrib)}
    for elem in root.iter():
        tag = elem.tag.replace(namespace, "")
        if tag == "properties":
            properties = {}
            for prop in elem.findall(f".//{namespace}property"):
                if not isinstance(prop, ET.Element):
                    continue
                name = prop.find(f"{namespace}name")
                if name is None:
                    continue
                value = prop.find(f"{namespace}value")
                properties[name.text] = value.text if value is not None else value
            parsed_dict["properties"] = properties
            return parsed_dict
        else:
            parsed_dict[tag] = dict(elem.attrib)
    return parsed_dict


def open_slide(filename: PathLike) -> "DeepZoomSlide":
    """
    Read slide with DeepZoomSlide backend. The input file should be a <slide_name>.dzi file with the deep zoom tiles
    in a folder <slide_name>_files

    Parameters
    ----------
    filename : PathLike
        DZI file for slide.
    """
    return DeepZoomSlide(filename)


class DeepZoomSlide(AbstractSlideBackend):

    def __init__(self, filename: PathLike):
        super().__init__(filename)
        self._tile_files = Path(self._filename).parent / f"{Path(self._filename).stem}_files"
        if self.properties.get("mpp-x") is not None and self.properties.get("mpp-y") is not None:
            self._spacings = [(float(self.properties["mpp-x"]), float(self.properties["mpp-y"]))]

        self._dz_level_count = math.ceil(
            math.log2(
                max(
                    self.dz_properties["Size"]["Width"],
                    self.dz_properties["Size"]["Height"],
                )
            )
        )
        self._tile_size = (self.dz_properties["Image"]["TileSize"],) * 2
        self._overlap = self.dz_properties["Image"]["Overlap"]

        self._level_count = self._dz_level_count + 1
        self._downsamples = [2**level for level in range(self._level_count)]
        self._shapes = [
            (
                math.ceil(self.dz_properties["Size"]["Width"] / downsample),
                math.ceil(self.dz_properties["Size"]["Height"] / downsample),
            )
            for downsample in self._downsamples
        ]

    @property
    def properties(self) -> dict[str, Any]:
        """Properties of slide"""
        if not hasattr(self, "_properties"):
            self._properties = self._fetch_properties()
        return self._properties

    @functools.lru_cache(maxsize=METADATA_CACHE)
    def _fetch_properties(self) -> dict[str, Any]:
        """Fetch properties of the slide. The `vips-properties.xml` file will be generated by vips when extracting
        the pyramid. Correctness not tested for vips-loader other than `openslideload`
        """
        vips_properties_file = self._tile_files / "vips-properties.xml"
        if not vips_properties_file.exists():
            return {}
        vips_properties_dict = parse_xml_to_dict(vips_properties_file)
        properties = {
            relevant_key.split("openslide.")[-1]: cast_fn(vips_properties_dict["properties"][relevant_key])
            for relevant_key, cast_fn in RELEVANT_VIPS_PROPERTIES.items()
            if relevant_key in vips_properties_dict["properties"]
        }
        if properties.get("vips-loader") is None or properties.get("vips-loader") != "openslideload":
            raise NotImplementedError(f"Properties not implemented for vips-loader {properties.get('vips-loader')}.")
        return properties

    @property
    def dz_properties(self) -> dict[str, Any]:
        """DeepZoom properties of slide"""
        if not hasattr(self, "_dz_properties"):
            self._dz_properties = self._fetch_dz_properties()
        return self._dz_properties

    @functools.lru_cache(maxsize=METADATA_CACHE)
    def _fetch_dz_properties(self) -> dict[str, Any]:
        """Fetch DeepZoom properties from .dzi file. Cast every property, except for `Format`, to integers."""
        _dz_properties = parse_xml_to_dict(self._filename)
        return {k: {ik: int(iv) if ik != "Format" else iv for ik, iv in v.items()} for k, v in _dz_properties.items()}

    @property
    def magnification(self) -> float | None:
        """Returns the objective power at which the WSI was sampled."""
        value = self.properties.get("objective-power")
        if value is not None:
            return int(value)
        return value

    @property
    def vendor(self) -> str | None:
        """Returns the scanner vendor."""
        return self.properties.get("vendor")

    @property
    def mode(self) -> str:
        """Returns the mode of the deep zoom tiles.
        NOTE: When generating deepzoom pyramid with VIPS, this could be CYMK and differ from the original slide
        """
        if not hasattr(self, "_mode"):
            self._mode = self._fetch_mode()
        return self._mode

    @functools.lru_cache(maxsize=METADATA_CACHE)
    def _fetch_mode(self) -> str:
        """Returns the mode of the deepzoom tile at level 0. This is an image of size 1x1 that should exist."""
        level_0_filename = self._tile_files / str(0) / f"0_0.{self.dz_properties['Image']['Format']}"
        if not level_0_filename.exists():
            raise FileNotFoundError("Deepzoom level 0 file does not exists. Cannot retrieve mode.")
        return str(Image.open(level_0_filename).mode)

    @property
    def slide_bounds(self) -> tuple[tuple[int, int], tuple[int, int]]:
        """Returns the bounds of the slide. These can be smaller than the image itself."""
        if self.properties.get("bounds-x") is None or self.properties.get("bounds-y") is None:
            return (0, 0), self.dimensions

        # If MRXS file is generate with --angle d90, x and width should be switched with y and height respectively
        bounds_offset = (self.properties["bounds-x"], self.properties["bounds-y"])
        bounds_size = (self.properties["bounds-width"], self.properties["bounds-height"])
        return bounds_offset, bounds_size

    def read_region(self, coordinates: tuple[Any, ...], level: int, size: tuple[int, int]) -> Image.Image:
        """Read region by stitching DeepZoom tiles together.

        Parameters
        ----------
        coordinates : tuple
            Coordinates of the region in level 0.
        level : int
            Level of the image pyramid.
        size : tuple
            Size of the region to be extracted.

        Returns
        -------
        PIL.Image
            The requested region.
        """
        level_downsample = self._downsamples[level]
        level_image_width, level_image_height = self._shapes[level]

        x, y = (coordinates[0] // level_downsample, coordinates[1] // level_downsample)
        w, h = size

        tile_w, tile_h = self._tile_size

        # Calculate the range of rows and columns for tiles covering the specified region
        start_row = y // tile_h
        level_end_row = level_image_height // tile_h + 1
        end_row = min(math.ceil((y + h) / tile_h), level_end_row)
        start_col = x // tile_w
        level_end_col = level_image_width // tile_w + 1
        end_col = min(math.ceil((x + w) / tile_w), level_end_col)

        indices = list(itertools.product(range(start_row, end_row), range(start_col, end_col)))
        level_dz = self._level_count - level - 1
        tile_format = self.dz_properties["Image"]["Format"]

        _region = Image.new(self.mode, size, (255,) * len(self.mode))
        for row, col in indices:
            tile_path = self._tile_files / str(level_dz) / f"{col}_{row}.{tile_format}"
            _region_tile = Image.open(tile_path)
            start_x = col * tile_w - x
            start_y = row * tile_h - y

            img_start_x = max(0, start_x)
            img_end_x = min(w, start_x + tile_w)
            img_start_y = max(0, start_y)
            img_end_y = min(h, start_y + tile_h)

            crop_start_x = img_start_x - start_x
            crop_end_x = img_end_x - start_x
            crop_start_y = img_start_y - start_y
            crop_end_y = img_end_y - start_y

            # All but edge tiles have overlap pixels outside of tile
            if col > 0:
                crop_start_x += self._overlap
                crop_end_x += self._overlap
            if row > 0:
                crop_start_y += self._overlap
                crop_end_y += self._overlap

            if col == level_end_col:
                crop_end_x -= self._overlap
            if row == level_end_row:
                crop_end_y -= self._overlap

            _cropped_region_tile = _region_tile.crop((crop_start_x, crop_start_y, crop_end_x, crop_end_y))
            _region.paste(_cropped_region_tile, (img_start_x, img_start_y))
        return _region

    def close(self) -> None:
        """Close the underlying slide"""
        return
