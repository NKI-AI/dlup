#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <tiffio.h>
#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <memory>
#include <stdexcept>
#include <cstdint>
#include <array>
#include <filesystem>
#include "stb_image_write.h"

namespace fs = std::filesystem;
namespace py = pybind11;

void save_buffer_as_image(const std::vector<std::byte>& buffer, int width, int height, int channels, const std::string& filename) {
    std::string extension = fs::path(filename).extension().string();
    std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);

    int result;
    if (extension == ".png") {
        result = stbi_write_png(filename.c_str(), width, height, channels, buffer.data(), width * channels);
    } else if (extension == ".jpg" || extension == ".jpeg") {
        result = stbi_write_jpg(filename.c_str(), width, height, channels, buffer.data(), 90); // 90 is the JPEG quality
    } else {
        throw std::invalid_argument("Unsupported file format. Use .png or .jpg/.jpeg");
    }

    if (result == 0) {
        throw std::runtime_error("Failed to save image");
    }
}

class TiffException : public std::runtime_error {
public:
    explicit TiffException(const std::string& message) : std::runtime_error(message) {}
};

class TiffOpenException : public TiffException {
public:
    explicit TiffOpenException(const std::string& message) : TiffException("Failed to open TIFF file: " + message) {}
};

class TiffWriteException : public TiffException {
public:
    explicit TiffWriteException(const std::string& message) : TiffException("Failed to write TIFF data: " + message) {}
};

class TiffSetupException : public TiffException {
public:
    explicit TiffSetupException(const std::string& message) : TiffException("Failed to setup TIFF: " + message) {}
};

enum class CompressionType {
    NONE,
    JPEG,
    LZW,
    DEFLATE
};

CompressionType string_to_compression_type(const std::string& compression) {
    if (compression == "NONE") return CompressionType::NONE;
    if (compression == "JPEG") return CompressionType::JPEG;
    if (compression == "LZW") return CompressionType::LZW;
    if (compression == "DEFLATE") return CompressionType::DEFLATE;
    throw std::invalid_argument("Invalid compression type: " + compression);
}

struct TIFFDeleter {
    void operator()(TIFF* tif) const noexcept {
        if (tif) {
            // Disable error reporting temporarily
            TIFFErrorHandler oldHandler = TIFFSetErrorHandler(nullptr);

            // Attempt to flush any pending writes
            if (TIFFFlush(tif) == 0) {
                TIFFError("TIFFDeleter", "Failed to flush TIFF data");
            }

            TIFFClose(tif);
            TIFFSetErrorHandler(oldHandler);
        }
    }
};

using TIFFPtr = std::unique_ptr<TIFF, TIFFDeleter>;

class FastTiffWriter {
public:
    FastTiffWriter(fs::path filename,
                   std::array<int, 3> size,
                   double mpp,
                   std::array<int, 2> tile_size = {512, 512},
                   CompressionType compression = CompressionType::JPEG,
                   int quality = 100,
                   bool pyramid = false)
        : filename(std::move(filename)), size(size), mpp(mpp), tile_size(tile_size),
          compression(compression), quality(quality), pyramid(pyramid),
          tif(nullptr)
    {
        validateInputs();

        TIFF* tiff_ptr = TIFFOpen(this->filename.c_str(), "w");
        if (!tiff_ptr) {
            throw TiffOpenException("Unable to create TIFF file");
        }
        tif.reset(tiff_ptr);

        setupTIFFDirectory(0);
    }

    void writeTile(py::array_t<std::byte, py::array::c_style | py::array::forcecast> tile, int row, int col);
    std::vector<std::byte> readTile(int level, int row, int col);;
    void writePyramid();
    std::vector<std::byte> readRegion(int level, int startRow, int endRow, int startCol, int endCol);

    void flush() {
    if (tif) {
        if (TIFFFlush(tif.get()) != 1) {
            throw TiffWriteException("Failed to flush TIFF file");
        }
    }
}

private:
    std::string filename;
    std::array<int, 3> size;
    double mpp;
    std::array<int, 2> tile_size;
    CompressionType compression;
    int quality;
    bool pyramid;
    int num_levels;
    TIFFPtr tif;

    void validateInputs() const;
    int calculateLevels();
    void setupTIFFDirectory(int level);
    void writeTIFFDirectory();
    std::pair<uint32_t, uint32_t> getLevelDimensions(int level);
    std::pair<uint32_t, uint32_t> getLevelTileDimensions(int level);
    std::string getDlupVersion() const;
};

void FastTiffWriter::writeTile(py::array_t<std::byte, py::array::c_style | py::array::forcecast> tile, int row, int col)
{
        auto buf = tile.request();
        if (buf.ndim < 2 || buf.ndim > 3) {
            throw TiffWriteException("Invalid number of dimensions in tile data. Expected 2 or 3, got " + std::to_string(buf.ndim));
        }
        auto [height, width, channels] = std::tuple{buf.shape[0], buf.shape[1], buf.ndim > 2 ? buf.shape[2] : 1};

        // Verify dimensions and buffer size
        size_t expected_size = static_cast<size_t>(width) * height * channels;
        if (static_cast<size_t>(buf.size) != expected_size) {
            throw TiffWriteException("Buffer size does not match expected size. Expected " + std::to_string(expected_size) + ", got " + std::to_string(buf.size));
        }

        // Check if tile coordinates are within bounds
        if (row < 0 || row >= size[0] || col < 0 || col >= size[1]) {
            throw TiffWriteException("Tile coordinates out of bounds for row " + std::to_string(row) + ", col " + std::to_string(col) + ". Image size is " + std::to_string(size[0]) + "x" + std::to_string(size[1]));
        }

        // Write the tile
        if (TIFFWriteTile(tif.get(), buf.ptr, col, row, 0, 0) < 0) {
            throw TiffWriteException("TIFFWriteTile failed for row " + std::to_string(row) + ", col " + std::to_string(col));
        }
    }

void FastTiffWriter::validateInputs() const {
        if (size[0] <= 0 || size[1] <= 0 || size[2] <= 0) {
            throw std::invalid_argument("Invalid size parameters");
        }
        if (mpp <= 0) {
            throw std::invalid_argument("Invalid mpp value");
        }
        if (tile_size[0] <= 0 || tile_size[1] <= 0) {
            throw std::invalid_argument("Invalid tile size");
        }
        if (quality < 0 || quality > 100) {
            throw std::invalid_argument("Invalid quality value");
        }
    }

int FastTiffWriter::calculateLevels() {
        int max_dim = std::max(size[0], size[1]);
        int min_tile_dim = std::min(tile_size[0], tile_size[1]);
        int num_levels = 1;
        while (max_dim > min_tile_dim) {
            max_dim /= 2;
            num_levels++;
        }
        return num_levels;
    }

std::string FastTiffWriter::getDlupVersion() const {
    py::module_ dlup = py::module_::import("dlup");
    return dlup.attr("__version__").cast<std::string>();
}

std::pair<uint32_t, uint32_t> FastTiffWriter::getLevelDimensions(int level) {
    uint32_t width = std::max(1, size[1] >> level);
    uint32_t height = std::max(1, size[0] >> level);
    return {width, height};
}

std::pair<uint32_t, uint32_t> FastTiffWriter::getLevelTileDimensions(int level) {
    auto [levelWidth, levelHeight] = getLevelDimensions(level);

    int numTilesX = (levelWidth + tile_size[1] - 1) / tile_size[1];
    int numTilesY = (levelHeight + tile_size[0] - 1) / tile_size[0];

    return {numTilesX, numTilesY};
    }

void FastTiffWriter::setupTIFFDirectory(int level) {
        auto set_field = [this](uint32_t tag, auto... value) {
            if (TIFFSetField(tif.get(), tag, value...) != 1) {
                throw TiffSetupException("Failed to set TIFF field: " + std::to_string(tag));
            }
        };

        auto [width, height] = getLevelDimensions(level);
        std::cout << "Level " << level << " dimensions: " << width << "x" << height << std::endl;

        int channels = size[2];

        set_field(TIFFTAG_IMAGEWIDTH, width);
        set_field(TIFFTAG_IMAGELENGTH, height);
        set_field(TIFFTAG_SAMPLESPERPIXEL, channels);
        set_field(TIFFTAG_BITSPERSAMPLE, 8);
        set_field(TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);
        set_field(TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
        set_field(TIFFTAG_TILEWIDTH, tile_size[1]);
        set_field(TIFFTAG_TILELENGTH, tile_size[0]);

        if (channels == 3 || channels == 4) {
            set_field(TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
        } else {
            set_field(TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
        }

        if (channels == 4) {
            uint16_t extra_samples = EXTRASAMPLE_ASSOCALPHA;
            set_field(TIFFTAG_EXTRASAMPLES, 1, &extra_samples);
        } else if (channels > 4) {
            std::vector<uint16_t> extra_samples(channels - 3, EXTRASAMPLE_UNSPECIFIED);
            set_field(TIFFTAG_EXTRASAMPLES, channels - 3, extra_samples.data());
        }

        switch (compression) {
            case CompressionType::NONE:
                set_field(TIFFTAG_COMPRESSION, COMPRESSION_NONE);
                break;
            case CompressionType::JPEG:
                set_field(TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
                set_field(TIFFTAG_JPEGQUALITY, quality);
                set_field(TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
                set_field(TIFFTAG_YCBCRSUBSAMPLING, 2, 2);
                set_field(TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
                break;
            case CompressionType::LZW:
                set_field(TIFFTAG_COMPRESSION, COMPRESSION_LZW);
                break;
            case CompressionType::DEFLATE:
                set_field(TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);
                break;
            default:
                throw TiffSetupException("Unknown compression type");
        }

        // Convert mpp (micrometers per pixel) to pixels per centimeter
        double pixels_per_cm = 10000.0 / mpp;

        set_field(TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);
        set_field(TIFFTAG_XRESOLUTION, pixels_per_cm);
        set_field(TIFFTAG_YRESOLUTION, pixels_per_cm);

        // Set the image description
        std::string description = "{\"shape\": [" + std::to_string(height) + ", " + std::to_string(width) + ", " + std::to_string(channels) + "]}";
        set_field(TIFFTAG_IMAGEDESCRIPTION, description.c_str());

        // Set the software tag with version from dlup
        std::string software_tag = "dlup " + getDlupVersion() + " (libtiff " + std::to_string(TIFFLIB_VERSION) + ")";
        set_field(TIFFTAG_SOFTWARE, software_tag.c_str());

        // Set SubFileType for pyramid levels
        if (level == 0) {
            set_field(TIFFTAG_SUBFILETYPE, 0);
        } else {
            set_field(TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);
        }
    }

std::vector<std::byte> FastTiffWriter::readTile(int level, int row, int col) {
    if (!TIFFSetDirectory(tif.get(), level)) {
        throw TiffException("Failed to set directory to level " + std::to_string(level));
    }

    ttile_t tile = TIFFComputeTile(tif.get(), col, row, 0, 0);
    if (tile == (ttile_t)(-1)) {
        throw TiffException("Failed to compute tile number at level " + std::to_string(level) +
                            ", row " + std::to_string(row) + ", col " + std::to_string(col));
    }

    std::vector<std::byte> tile_buffer(TIFFTileSize(tif.get()));
    if (TIFFReadEncodedTile(tif.get(), tile, tile_buffer.data(), tile_buffer.size()) < 0) {
        throw TiffException("Failed to read tile at level " + std::to_string(level) +
                            ", row " + std::to_string(row) + ", col " + std::to_string(col) +
                            ". Tile number: " + std::to_string(tile));
    }

    return tile_buffer;
}

std::vector<std::byte> FastTiffWriter::readRegion(int level, int startRow, int endRow, int startCol, int endCol) {
    std::cout << "Entering readRegion: level=" << level << ", startRow=" << startRow
              << ", endRow=" << endRow << ", startCol=" << startCol << ", endCol=" << endCol << std::endl;

//    if (!TIFFSetDirectory(tif.get(), level)) {
//        throw TiffException("Failed to set directory to level " + std::to_string(level));
//    }

    uint32_t imageWidth, imageHeight, tileWidth, tileHeight, samplesPerPixel;
    TIFFGetField(tif.get(), TIFFTAG_IMAGEWIDTH, &imageWidth);
    TIFFGetField(tif.get(), TIFFTAG_IMAGELENGTH, &imageHeight);
    TIFFGetField(tif.get(), TIFFTAG_TILEWIDTH, &tileWidth);
    TIFFGetField(tif.get(), TIFFTAG_TILELENGTH, &tileHeight);
    TIFFGetField(tif.get(), TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);

    std::cout << "Image dimensions: " << imageWidth << "x" << imageHeight << std::endl;
    std::cout << "Tile dimensions: " << tileWidth << "x" << tileHeight << std::endl;
    std::cout << "Samples per pixel: " << samplesPerPixel << std::endl;

    std::cout << "Checking region coordinates" << std::endl;
    std::cout << "Region start: " << startRow << ", " << startCol << std::endl;
    std::cout << "Region end: " << endRow << ", " << endCol << std::endl;

    if (startRow < 0 || startCol < 0 || endRow > imageHeight || endCol > imageWidth) {
        throw TiffException("Invalid region coordinates for level " + std::to_string(level));
    }

    int width = endCol - startCol;
    int height = endRow - startRow;

    std::cout << "Region dimensions: " << width << "x" << height << std::endl;

    if (width <= 0 || height <= 0) {
        throw TiffException("Invalid region size");
    }

    std::vector<std::byte> regionBuffer(width * height * samplesPerPixel);

    for (int row = startRow; row < endRow; row += tileHeight) {
        for (int col = startCol; col < endCol; col += tileWidth) {
            std::cout << "Processing tile at row=" << row << ", col=" << col << std::endl;

            ttile_t tile = TIFFComputeTile(tif.get(), col, row, 0, 0);
            if (tile == (ttile_t)(-1)) {
                throw TiffException("Failed to compute tile number for row=" + std::to_string(row) + ", col=" + std::to_string(col));
            }

            std::cout << "Computed tile number: " << tile << std::endl;

            tsize_t tileSize = TIFFTileSize(tif.get());
            std::vector<std::byte> tileBuffer(tileSize);

            std::cout << "Reading tile of size: " << tileSize << std::endl;

            if (TIFFReadEncodedTile(tif.get(), tile, tileBuffer.data(), tileSize) < 0) {
                throw TiffException("Failed to read tile at row=" + std::to_string(row) + ", col=" + std::to_string(col));
            }

            int rowsToRead = std::min(static_cast<int>(tileHeight), endRow - row);
            int colsToRead = std::min(static_cast<int>(tileWidth), endCol - col);

            std::cout << "Copying " << rowsToRead << "x" << colsToRead << " pixels from tile to region buffer" << std::endl;

            for (int tileRow = 0; tileRow < rowsToRead; ++tileRow) {
                for (int tileCol = 0; tileCol < colsToRead; ++tileCol) {
                    for (uint32_t sample = 0; sample < samplesPerPixel; ++sample) {
                        size_t srcIdx = (tileRow * tileWidth + tileCol) * samplesPerPixel + sample;
                        size_t dstIdx = ((row - startRow + tileRow) * width + (col - startCol + tileCol)) * samplesPerPixel + sample;

                        if (srcIdx >= tileBuffer.size() || dstIdx >= regionBuffer.size()) {
                            throw TiffException("Buffer overflow: srcIdx=" + std::to_string(srcIdx) +
                                                ", dstIdx=" + std::to_string(dstIdx) +
                                                ", tileBuffer.size()=" + std::to_string(tileBuffer.size()) +
                                                ", regionBuffer.size()=" + std::to_string(regionBuffer.size()));
                        }

                        regionBuffer[dstIdx] = tileBuffer[srcIdx];
                    }
                }
            }
        }
    }

    std::cout << "Exiting readRegion successfully" << std::endl;
    return regionBuffer;
}

void FastTiffWriter::writePyramid() {
    num_levels = calculateLevels();

    // Close and reopen the TIFF file in read-write mode
    tif.reset(TIFFOpen(filename.c_str(), "r+"));
    if (!tif) {
        throw TiffException("Failed to reopen TIFF file for pyramid writing");
    }

    // Ensure we're at the base level directory
    if (!TIFFSetDirectory(tif.get(), 0)) {
        throw TiffException("Failed to set directory to base level");
    }

    for (int level = 1; level < num_levels; ++level) {
        auto [numTilesX, numTilesY] = getLevelTileDimensions(level);
        auto [levelWidth, levelHeight] = getLevelDimensions(level);

        std::cout << "This is level " << level << " with " << numTilesX << "x" << numTilesY << " tiles" << std::endl;

        try {
            setupTIFFDirectory(level);

            // Set the SubfileType tag to indicate this is a reduced resolution version
            if (TIFFSetField(tif.get(), TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE) != 1) {
                throw TiffSetupException("Failed to set SubfileType tag for level " + std::to_string(level));
            }

            // Set the image dimensions for this level
            if (TIFFSetField(tif.get(), TIFFTAG_IMAGEWIDTH, levelWidth) != 1 ||
                TIFFSetField(tif.get(), TIFFTAG_IMAGELENGTH, levelHeight) != 1) {
                throw TiffSetupException("Failed to set image dimensions for level " + std::to_string(level));
            }
        } catch (const TiffSetupException& e) {
            throw TiffException("Failed to set up directory for level " + std::to_string(level) +
                                ": " + std::string(e.what()));
        }

        // Create an empty tile filled with zeros
        std::vector<std::byte> emptyTileData(tile_size[0] * tile_size[1] * size[2], std::byte{0});

        for (int tileY = 0; tileY < numTilesY; ++tileY) {
            for (int tileX = 0; tileX < numTilesX; ++tileX) {
                try {
                    py::array_t<std::byte> tileArray({tile_size[0], tile_size[1], size[2]}, emptyTileData.data());
                    writeTile(tileArray, tileY * tile_size[0], tileX * tile_size[1]);
                    std::cout << "Wrote empty tile at level " << level << ", tileY=" << tileY << ", tileX=" << tileX << std::endl;
                } catch (const TiffException& e) {
                    std::cerr << "Error writing empty tile: " << e.what() << std::endl;
                }
            }
        }

        // Write the directory for this level
        if (!TIFFWriteDirectory(tif.get())) {
            throw TiffException("Failed to write directory for level " + std::to_string(level));
        }
        std::cout << "Finished writing level " << level << std::endl;
    }

    // Ensure all data is written to the file
    TIFFFlush(tif.get());

    std::cout << "Pyramid writing complete" << std::endl;
}

PYBIND11_MODULE(fast_tiff_writer, m) {
    py::class_<FastTiffWriter>(m, "FastTiffWriter")
        .def(py::init([](py::object path, std::array<int, 3> size, double mpp,
                         std::array<int, 2> tile_size,
                         py::object compression, int quality, bool pyramid) {
            fs::path cpp_path;
            if (py::isinstance<py::str>(path)) {
                cpp_path = fs::path(path.cast<std::string>());
            } else if (py::hasattr(path, "__fspath__")) {
                cpp_path = fs::path(path.attr("__fspath__")().cast<std::string>());
            } else {
                throw py::type_error("Expected str or os.PathLike object");
            }

            CompressionType comp_type;
            if (py::isinstance<py::str>(compression)) {
                comp_type = string_to_compression_type(compression.cast<std::string>());
            } else if (py::isinstance<CompressionType>(compression)) {
                comp_type = compression.cast<CompressionType>();
            } else {
                throw py::type_error("Expected str or CompressionType for compression");
            }

            return new FastTiffWriter(std::move(cpp_path), size, mpp, tile_size, comp_type, quality);
        }))
        .def("write_tile", &FastTiffWriter::writeTile)
        .def("write_pyramid", &FastTiffWriter::writePyramid)
        .def("flush", &FastTiffWriter::flush);


    py::enum_<CompressionType>(m, "CompressionType")
        .value("NONE", CompressionType::NONE)
        .value("JPEG", CompressionType::JPEG)
        .value("LZW", CompressionType::LZW)
        .value("DEFLATE", CompressionType::DEFLATE);

    py::register_exception<TiffException>(m, "TiffException");
    py::register_exception<TiffOpenException>(m, "TiffOpenException");
    py::register_exception<TiffWriteException>(m, "TiffWriteException");
    py::register_exception<TiffSetupException>(m, "TiffSetupException");
}
